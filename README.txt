Το πρόγραμμα έχει 3 πηγαία αρχεία:

1) Το crossword.c το οποίο διαβάζει από τη γραμμή εντολής ορισμένες
   πληροφορίες από τον χρήστη, όπως το σταυρόλεξο, ή προαιρετικά
   ενα λεξικό διαφορετικό από το Words.txt (με τη χρήση της εντολής -dict)
   και επίσης προαιρετικά κάποια από τις εντολές -check ή -draw.
   Το αρχείο αυτό κάνει την εκτύπωση των των λύσεων ενός σταυρόλεξου
   είτε ζωγραφισμένο (με -draw), είτε την μία λέξη κάτω από την άλλη. 
2) Το solve_crossword.c το οποίο δέχεται μεταξύ άλλων πληροφοριών το
   δεδομένο σταυρόλεξο και λεξικό οταν δεν δινεται ως όρισμα της
   γραμμης εντολής το -check, ώστε να προσπαθήσει να βρει κάποια 
   λύση του σταυρόλεξου.
3) To check.c το οποίο δέχεται καθαρά πληροφορίες για το
   δεδομένο σταυρόλεξο και λεξικό αν και μόνο αν δωθεί
   ως όρισμα της γραμμής εντολής το -check και ελέγχει
   αν μία λύση (που διαβάζει από την πρότυπη είσοδο)
   του σταυρόλεξου είναι σωστή ή όχι.

Επίσης έχει 2 header files:

1) Το crossword.h το οποίο περιέχει τις απαραίτητες συναρτήσεις
για το crossword.c, το solve_crossword.c και το check.c

2)Το crossword_structs.h το οποίο περιέχει τις απαραίτητες
δομές (structs) για τα crossword.c, solve_crossword.c και check.c 

ΠΡΟΣΟΧΗ ΣΤΗ ΧΡΗΣΗ ΛΕΞΙΚΩΝ (ΧΑΡΑΚΤΗΡΑΣ ΑΛΛΑΓΗΣ ΓΡΑΜΜΗΣ)
  Το πρόγραμμα, σύμφωνα με τις προδιαγραφές του προβλήματος,
  θεωρεί ότι έχει διαβάσει μία λέξη όποτε διαβάζει έναν χαρακτήρα αλλαγής
  γραμμής. Οπότε αν το τελευταίο γράμμα στο λεξικό δεν ακολουθείται από αλλαγή γραμμής
  το πρόγραμμα δεν θα δουλέψει σωστά γιατί παραχωρώ όση μνήμη χρειάζεται για τις λέξεις
  που μέτρησα οτι υπάρχουν (δηλαδή το πόσα '\n' υπάρχουν).

Ο σωστός τρόπος εκτέλεσης του προγράμματος είναι ο εξής:
    Ως πρώτο όρισμα (εξαιρείται το ./executable, δηλαδή εννοώ το argv[1]) πρέπει αναγκαστικά
    να δωθεί το όνομα του αρχείου του σταυρόλεξου.
    Τα υπόλοιπα ορίσματα είναι κατα μία έννοια προαιρετικά, αφού το πρόγραμμα μπορει να τρέξει και χωρίς αυτά.
    Αν το πρόγραμμα εκτελεστεί μόνο με το όνομα του αρχείου του σταυρόλεξου, θα προσπαθήσει να διαβάσει
    λέξεις από ένα default λεξικό Words.txt και αν βρει λύση θα εκτυπώσει με τη σωστη σειρά τις λέξεις που
    έλυσαν το σταυρόλεξο τη μια κάτω από την άλλη.
 
    Ως δεύτερο όρισμα μπορεί να δωθεί όποιαδήποτε εντολή από το σύνολο εντολών {-check, -dict, -draw}. 

    Ως τρίτο όρισμα, αν έχει δωθεί ως δεύτερο όρισμα η εντολή -dict, το πρόγραμμα περιμένει
    αναγκαστικά να διαβάσει το όνομα του λεξικού που επιθυμεί ο χρήστης να χρησιμοποιήσει.
    Διαφορετικά, αν δηλαδή έχει δωθεί ως δεύτερο όρισμα το -check ή το -draw, ο χρήστης είναι 
    ελεύθερος να δώσει ως τρίτο όρισμα οποιαδήποτε από τις υπόλοιπες εντολές. Η επανάληψη
    μίας εντολής στη γραμμη εντολών δεν απαγορεύεται, απλώς δεν θα αλλάξει απολύτως τίποτα,
    όμως στον οδηγό εκτέλεσης του προγράμματος κάνω την παραδοχή ότι δεν γίνεται επανάληψη
    ορισμάτων.
	
    Ως τέταρτο όρισμα, αν το τρίτο όρισμα είναι το -dict, ξανά αναγκαστικά πρέπει να διαβαστεί
    το όνομα του αρχείου του λεξικού. Διαφορετικά μπορεί πλέον να χρησιμοποιηθεί μόνο η εντολή 
    -dict.
    Και τέλος, ως πέμπτο όρισμα, μπορεί να είναι η εντολή που έμεινε από τις {-check, -draw}, είτε
    το όνομα του αρχείου λεξικού σε περιίπτωση που δώθηκε ως προηγούμενο όρισμα το -dict.


Λίγα λόγια για πρόγραμμα επίλυσης σταυρόλεξων:

1) Η μοντελοποίηση:
    Προσεγγίζω το πρόβλημα ως ένα γενικό CSP (Constraint Satisfaction Problem), και βρίσκω αρχικά ποιες είναι οι μεταβλητές του
    σταυρόλεξου. Μου φάνηκε λογικό να διακρίνω τις μεταβλητές σε οριζόντιες και κάθετες, καθώς οι γειτονικές μεταβλητές
    μίας μεταβλητής είναι πάντοτε του άλλου τύπου, οπότε αυτή η διάκριση με βολεύει στην αναζήτηση των γειτόνων.
    
    Για την συγκέντρωση των απαραίτητων πληροφοριών για κάθε μεταβλητή χρησιμοποιώ ένα struct var το οποίο
    αποτελεί και τον τύπο δεδομένων των μεταβλητών.	

    Κάθε μεταβλητή έχει και το δικό της domain, το οποίο είναι το σύνολο των λέξεων που θα μπορούσαν να ανατεθούν στη
    μεταβλητή, καθώς και το δικό της cardinality, που έιναι η πληθικότητα του συνόλου λέξεων του domain (Ίσως το
    όνομα δεν είναι το καλύτερο δυνατό γιατί αν το σύνολο έχει λέξεις που επαναλαμβάνονται, θα τις μετρήσω και
    αυτές στο cardinality, αλλά κρατάω το όνομα γιατί είναι εύκολο στην κατανόηση). Διατηρώ
    την κατάσταση του domain και του cardinality μιας μεταβλητής ωθώντας τα σε στοίβες στις οποίες
    το πιο πρόσφατο στοιχείο που προστέθηκε στη στοίβα αναπαριστά την τωρινή κατάσταση του
    domain/cardinality της μεταβλητής.

        Άλλες σημαντικές πληροφορίες που διατηρώ για τις μεταβλητές:
    
        1) Το επίπεδο στο οποίο έχει γίνει ή πάει να γίνει ανάθεση μίας μεταβλητής.
           Με επίπεδο εννοώ τη σειρά με την οποία ανατέθηκε τιμή στη μεταβλητή.
           Πχ η 2η μεταβλτή έχει επίπεδο 2, ενώ η 3η έχει επίπεδο 3.
        2) Τις γειτονικές μεταβλητές κάθε μεταβλητής
        3) Τις θέσεις των σημείων στις οποίες τέμνεται μία μεταβλητή με
           τη γειτονική της. 
        4) Τα επίπεδα των γειτόνων μίας μεταβλητής οι οποίοι πείραξαν
           το domain της μεταβλητής μέσω του forward check (Στο οποίο θα 
           απευθυνθώ στο κομμάτι που αφορά στην επίλυση).
           Τα επίπεδα αυτά τα σώζω σε μία στοίβα με όνομα pastfc.
        5) Ένα conflict set που περιέχει όχι μόνο τα επίπεδα των μεταβλητών 
           που πείραξαν το domain της ίδιας της μεταβλητής, αλλά και ένα συγκεκριμένο
           conflict set κάποιας μεταβλητής η οποία έπαθε domain wipeout κατα το forward check μίας μεταβλητής η οποία απέτυχε. Επίσης 
           περιέχει το conflict set της μεταβλητής που απέτυχε και υπαναχώρησε στη μεταβλητή.
           στην εύρεση λέξης να της ανατεθεί ώστε να μην προκαλείται domain wipeout σε γείτονα.
           Το συγκεκριμένο αυτό conflict set που ανέφερα ονομάζεται Earliest Minimal Conflict set (emc) και
           είναι εκείνο το conflict set κάποιας από τις μεταβλητές που έπαθαν domain wipeout το οποίο περιέχει
           το ελάχιστο μή κοινό max στοιχείο όλων των μεταβλητών που έπαθαν domain wipeout σε κάποιο σημείο του
           forward check της μεταβλητής. Πχ αν έχουμε 2 conflict sets: Conf1 = {0, 3, 5, 7}, Conf2 = {1, 2, 5, 7}
           emc = Conf2 γιατί max{Conf2 - Conf1} = 2 < max{Conf1 - Conf2} = 3.
           Τα conflict sets τα αναπαριστώ με πίνακες μεγέθους ίσο με τον αριθμό όλων των μεταβλητών.
           Το conflict set είναι συμαντικό γιατί επιτρέπει το CBJ (Conflict-Directed Backjumping)

2) Η επίλυση

    Για την επίλυση του προβλήματος χρησιμοποιώ FC (Forward Checking) και CBJ (Conflict-Directed Backjumping)
    καθώς και το MRV heuristic.
    Οι πηγές απο τις οποίες άντλησα πληροφορίες που με βοήθησαν στην υλοποίηση τους θα αναφερθούν στο τέλος.
    To MRV είναι αρκετά απλό, το υλοποιώ απλά με μια συνάρτηση που συγκρίνει τα τρέχοντα cardinalities όλων
    των μεταβλητών στις οποιές δεν έχουν ανατεθεί τιμές και γυρνάει την διεύθυνση της μεταβλητής με το μικρότερο
    cardinality.
    Η ιδέα είναι ότι θέλω να αποτύχω γρήγορα ώστε να επιταχύνω την αναζήτηση.

    Το FC, του οποίου ο σκοπός είναι να απλοποιήσει τα domains των γειτονικών μεταβλητών στις οποίες
    δεν έχει ανατεθεί τιμή για λιγότερες περιττές δοκιμές, υλοποιείται με την εξής διαδικασία.

      1) Παίρνω μια μεταβλητή (είτε απο το MRV είτε μία που με ανάγκασε να πάρω το CBJ) και δοκιμάζω μία λέξη
      2) Αναγκάζω τα domains των unassigned γειτόνων μου να περιέχουν μόνο λέξεις που το ίδιο
         γράμμα στην τομή τους με τη μεταβλητή που έχει και η λέξη που δοκιμάζεται
      3) Αν προκλήθηκε domain wipeout, αφού συγκεντρώσω κάποιες πληροφορίες που αφορούν το CBJ και όχι το 
         FC, γυρνάω κάθε domain, cardinality και pastfc (που είναι οι στοίβες που αλλάζουν στο FC) στην προηγούμενη
         τους μορφή κάνοντας απώθηση από τη στοίβα μία φορά. 
    
    Το CBJ που χρησιμοποιώ έχει το εξής σκεπτικό:
         Αν μία μεταβλητή έκανε domain wipeout τουλάχιστον έναν γείτονα για κάθε λέξη στο domain της,
	      τότε μπορεί να οφείλεται είτε στο ότι άλλες μεταβλητές πείραξαν κάποιον από τους γείτονες στο
	      σημείο που το domain του να μην επιβίωσε το forward check της μεταβλητής, είτε στο γεγονός
	      ότι οι assigned γείτονες της μεταβλητής που έκανε το forward check της πείραξαν το domain
              έτσι ώστε να της βγάλουν εκείνες τις λέξεις που θα ήταν συμβατές με τα domains των γειτόνων της.
         Επομένως αντί να υπαναχωρώ με χρονολογικό backtrack στην προηγούμενη μεταβλητή που της ανατέθηκε τιμή,
	      μπορώ να κρατήσω επίπεδα προβληματικών μεταβλητών στα conflict sets ώστε να υπαναχωρώ στην τελευταία
         (πιο πρόσφατη) μεταβλητή που θα μπορούσε να αλλάξει το αποτέλεσμα του forward check (δηλαδή να μην γίνει ξανά 
	      domain wipeout).
    
         Πάνω περιέγραψα ένα τεχνικό κομμάτι της διαδικασίας του CBJ. Στην ουσία απλά αναπαριστώ τα σύνολα
         με int arrays, και χρησιμοποιώ κάποιες συναρτήσεις που εκτελούν λειτουργίες όπως την ένωση 2 συνόλων,
         την έυρεση του μέγιστου στοιχείου ενός συνόλου, την πρόσθεση/αφαίρεση στοιχείου κλπ.

Οι πηγές από τις οποίες άντλησα πληροφορίες είναι οι εξείς:
    (1) Crossword Puzzles and Constraint Satisfaction (James Connor, John Duchi, and Bruce Lo)
    
    Το paper (1) βοήθησε στην κατασκευή του FC, του MRV και τη μοντελοποιήση του προγράμματος

    (2) Backjump-based backtracking for constraint satisfaction problems (Rina Dechter, Daniel Frost)
    
    Το paper (2) βοήθησε στην κατανόηση της ιδέας πίσω από το CBJ
